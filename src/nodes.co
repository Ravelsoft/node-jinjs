
{ parse_block, parse_extends, parse_macro, parse_for, parse_let, make_expression } = require \./expression

/**
 *  @param str  a string
 *  @returns    an escaped string suitable to be quoted.
 */
function escape (str) ->
    str.replace /\\/g, '\\\\' # Backslash escaping
        .replace /["']/g, (str) -> # Quote escaping
            "\\#{str}"
        .replace /\n/g, '\\n' # New line escaping

class Exception
    (msg) ->
        @message = msg
class JinJSUnimplementedException extends Exception
    -> super ...
class JinJSUnexpectedError extends Exception
    -> super ...

/**
 *
 */
class Node
    (specs) ->
        @contents = specs.contents if specs?.contents
    compile: ->
        throw new JinJSUnimplementedException
    ind: (opts) ->
        opts.__indent__ ?= 0
        opts.__indent__ = opts.__indent__ + 1
        ind = opts.__indent__ * 4
        return "\n" + (" " * ind)
    ded: (opts) ->
        opts.__indent__ ?= 1
        opts.__indent__ = opts.__indent__ - 1
        ind = opts.__indent__ * 4
        return "\n" + " " * ind
    cur: (opts) ->
        ind = (opts.__indent__ ? 0) * 4
        return "\n" + " " * ind
/**
 *
 */
class NodeBasic extends Node
    (specs) -> super ...
    compile: function (opts, ctx) ->
        "#{@cur opts}_res += '#{escape @contents}';"

    append: function (contents) ->
        @contents += contents

class NodeComment extends Node
    (specs) ->
        @contents = specs.contents ? ""

    compile: function (opts, ctx) ->
        "#{@cur opts}/*#{@contents}*/"

/**
 *  A collection of Nodes.
 */
class NodeList extends Node
    (specs) ->
        @nodes = []
        super ...

    push: function (node) ->
        if not node?
            return

        if typeof node == \string # node is a String
            last_node = @nodes[@nodes.length - 1]
            if last_node instanceof NodeBasic
                last_node.append node
            else
                @nodes.push new NodeBasic contents: node
        else
            @nodes.push node
        
    compile: function (opts, ctx) ->
        ctx ?= {}
        res = ""
        for node of @nodes
            res += node.compile opts, ctx
        return res

/**
 *
 */
class NodePrint extends Node
    (specs) -> super ...
    compile: function (opts, ctx) ->
        return "#{@cur opts}_res += (#{make_expression @contents, ctx} || '').toString();"

class NodeTag extends Node
    @tag = \__tag__
    (specs) -> super ...
    compile: ->
        throw new JinJSUnimplementedException "The NodeTag is not meant to be used !"

    toString: ->
        return "Node: #{this.constructor.displayName}"

/**
 *
 */
class NodeExtends extends NodeTag
    @tag = \extends

    (specs) -> super ...

    compile: function (opts, ctx) ->
        opts.'extends' = true
        tpl_name = parse_extends @contents, opts
        return "#{@cur opts}__extends__ = __get_template__ (#{tpl_name});"

/**
 *
 */
class NodeInclude extends NodeTag
    @tag = \include

    (specs) -> super ...

    compile: function (opts, ctx) ->
        return "#{@cur opts}_res += __get_template__ (#{make_expression @contents, ctx}).render(__ctx__);"

/**
 *
 */
class NodeLet extends NodeTag
    @tag = \let

    (specs) -> super ...

    compile: function (opts, ctx) ->
        { variable_name, expression } = parse_let @contents, ctx

        ctx[variable_name] = true # The variable name is now accessible to the rest of the template.
        return res = "#{@cur opts}var #{variable_name} = (__ctx__.#{variable_name} = #{expression});"

class NodeDo extends NodeTag
    @tag = \do
    (specs) -> super ...

    compile: function (opts, ctx) ->
        return "#{@cur opts}#{make_expression @contents, ctx};"

/**
 */
class NodeTagContainer extends NodeList
    (specs) ->
        super ...
        @child_node = specs.child_node

    child_code: (opts, ctx) ->
        return (@child_node?.compile opts, ctx) ? ""

/**
 *
 */
class NodeMacro extends NodeTagContainer
    @tag = \macro
    @until = \endmacro

    (specs) -> super ...

    init_defaults: (opts, args) ->
        res = ""
        for a in args
            if a.default_value
                res += "#{@cur opts}#{a} = (#{a} === undefined) ? (#{a.default_value}) : #{a};"

    compile: (opts, ctx) ->
        { args, function_name } = parse_macro @contents, ctx

        ctx[function_name] = true # This macro is now accessible to all the template code that follows.
        new_ctx = {} <<< ctx

        for argname of args
            new_ctx[argname] = true

        return "#{@cur opts}function #{function_name}(#{args.join ", "}) {
                    #{@ind opts}var _res = '';
                    #{@init_defaults opts, args}
                    #{@child_code opts, new_ctx}
                    #{@cur opts}return _res;
                #{@ded opts}}
                #{@cur opts}__ctx__.#{function_name} = #{function_name};
                "

/**
 *
 */
class NodeBlock extends NodeTagContainer
    @tag = \block
    @until = \endblock

    (specs) -> super ...

    compile: (opts, ctx) ->
        block_name = parse_block @contents, ctx
        opts.blocks ?= {}

        new_ctx = {\super : true} <<< ctx

        # Output the block expression into the block
        indent = opts.__indent__
        opts.__indent__ = 4
        opts.blocks[block_name] = "#{@cur opts}var _res = '';
                #{@child_code opts, new_ctx}
                #{@cur opts}return _res;"
        opts.__indent__ = indent

        return "#{@cur opts}// Adding the current block as the super of the currently defined block with the same name.
            #{@cur opts}if (_b['#{block_name}'] !== undefined) {
            #{@ind opts}(function (original) {
                #{@ind opts}_b['#{block_name}'] = function (__ctx__) { return original.call ({ super: __block_#{block_name}}, __ctx__); };
            #{@ded opts}})(_b['#{block_name}']);
        #{@ded opts}} else { _b['#{block_name}'] = __block_#{block_name}; }
        #{@cur opts}if (__extends__ === null) _res += _b['#{block_name}'](__ctx__);"



class NodeElse extends NodeTagContainer
    @tag = \else

    @parse = function (pd) ->
        return new NodeElse child_node: pd.child_node

    (specs) ->
        super ...

    compile: (opts, ctx) ->
        res = "#{@ded opts}} else {" 
        @ind opts
        res += "#{@child_code opts, ctx}"
        return res

class NodeElseIf extends NodeTagContainer
    @tag = \elseif
    @inside = elseif: NodeElseIf, else: NodeElse

    (specs) ->
        super ...

    compile: function (opts, ctx) ->
        res = "#{@ded opts}} else if (#{make_expression @contents, ctx}) {"
        @ind opts
        res += "#{@child_code opts, ctx}"
        return res

class NodeIf extends NodeTagContainer
    @tag = \if
    @until = \endif
    @inside = else: NodeElse, elseif: NodeElseIf

    (specs) ->
        super ...

    compile: function (opts, ctx) ->
        res = "#{@cur opts}if (#{make_expression @contents, ctx}) {"
        @ind opts
        res += "#{@child_code opts, ctx}#{super.call this, opts, ctx}
        #{@ded opts}}"
        return res


class NodeElseFor extends NodeTagContainer
    @tag = \else
    @until = \endfor

    @parse = function (pd) ->
        return new NodeElseFor child_node: pd.child_node
    
    (specs) ->
        super ...

    compile: function (opts, ctx) ->
        # loop.index is not defined if we didn't enter the loop.
        res = "#{@ded opts}if (loop.index === undefined) {"
        @ind opts
        res += "#{@child_code opts, ctx}#{@ded opts}}"
        return res


#   A Node that emulates the for () { } statement.
#  
class NodeFor extends NodeTagContainer
    @tag = \for
    @until = \endfor
    @inside = else: NodeElseFor

    (specs) ->
        super ...

    compile: function (opts, ctx) ->
        { key, value, condition } = parse_for @contents, ctx

        if not value # Iterating over an array.
            return "#{@cur opts}(function () {
                #{@ind opts}i = 0;
                #{@cur opts}var _ref = (#{condition}) || [];
                #{@cur opts}var _prev_loop = __ctx__.loop;
                #{@cur opts}var _prev_key = __ctx__.#{key};
                #{@cur opts}var loop = (__ctx__.loop = {length: _ref.length, callee: arguments.callee});
                #{@cur opts}for (i = 0; i < loop.length; i++) {
                    #{@ind opts}loop.index = i + 1; loop.index0 = i;
                    #{@cur opts}loop.first = (i == 0); loop.last = (i == loop.length - 1);
                    #{@cur opts}__ctx__.#{key} = _ref[i];
                    #{@child_code opts, ctx}
                #{@ded opts}}
                #{super.call this, opts, ctx}
                #{@cur opts}__ctx__.loop = _prev_loop;
                #{@cur opts}__ctx__.#{key} = _prev_key;
            #{@ded opts}})();"
        else # Iterating over an object.
            res = "#{@cur opts}(function () {
                #{@ind opts}x = '';
                #{@cur opts}i = 0;
                #{@cur opts}var _ref = (#{condition}) || {};
                #{@cur opts}var _prev_loop = __ctx__.loop;
                #{@cur opts}var _prev_key = __ctx__.#{key};
                #{@cur opts}var _prev_value = __ctx__.#{value};
                #{@cur opts}var loop = (__ctx__.loop = { callee: arguments.callee });
                #{@cur opts}for (x in _ref) {
                    #{@ind opts}if (_ref.hasOwnProperty(x)) {
                        #{@ind opts}loop.index0 = i;
                        #{@cur opts}loop.index = i + 1;
                        #{@cur opts}__ctx__.#{key} = x;
                        #{@cur opts}__ctx__.#{value} = _ref[x];
                        #{@child_code opts, ctx}
                        #{@cur opts}i += 1;
                    #{@ded opts}}
                #{@ded opts}}
                #{super.call this, opts, ctx}
                #{@cur opts}__ctx__.loop = _prev_loop;
                #{@cur opts}__ctx__.#{key} = _prev_key;
                #{@cur opts}__ctx__.#{value} = _prev_value;
            #{@ded opts}})();"
            return res

exports <<< { 
    NodeIf, NodeDo, NodeLet, NodeFor, NodeMacro, NodeList, NodeBasic, 
    NodePrint, NodeComment, NodeExtends, NodeInclude,
    default_nodes: do
        \if : NodeIf
        \do : NodeDo
        \let : NodeLet
        \for : NodeFor
        \macro : NodeMacro
        \extends : NodeExtends
        \block : NodeBlock
        \include : NodeInclude
    }

